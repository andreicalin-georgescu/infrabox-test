name: ðŸ“¦ Build Package and Create Release 

on:
  pull_request:
    types: [closed]
    branches:
      - main

permissions:
  contents: write
  pull-requests: read
  discussions: write

jobs:
  tag-and-build:
    if: github.event.pull_request.merged == true && (contains(github.event.pull_request.labels.*.name, 'release:patch') || contains(github.event.pull_request.labels.*.name, 'release:minor') || contains(github.event.pull_request.labels.*.name, 'release:major'))
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
      release_type: ${{ steps.determine_release.outputs.release_type }}
      pr_title: ${{ steps.extract_pr_info.outputs.pr_title }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine release type
        id: determine_release
        run: |
          if [[ ${{ contains(github.event.pull_request.labels.*.name, 'release:patch') }} == true ]]; then
            echo "release_type=patch" >> $GITHUB_OUTPUT
          elif [[ ${{ contains(github.event.pull_request.labels.*.name, 'release:minor') }} == true ]]; then
            echo "release_type=minor" >> $GITHUB_OUTPUT
          elif [[ ${{ contains(github.event.pull_request.labels.*.name, 'release:major') }} == true ]]; then
            echo "release_type=major" >> $GITHUB_OUTPUT
          fi

      - name: Extract PR information
        id: extract_pr_info
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          echo "pr_title=${PR_TITLE}" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: get_latest_tag
        run: |
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT
          
          # Parse version components
          if [[ $LATEST_TAG =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
            echo "major=$MAJOR" >> $GITHUB_OUTPUT
            echo "minor=$MINOR" >> $GITHUB_OUTPUT
            echo "patch=$PATCH" >> $GITHUB_OUTPUT
          fi

      - name: Create new tag based on release type
        id: create_tag
        run: |
          MAJOR=${{ steps.get_latest_tag.outputs.major }}
          MINOR=${{ steps.get_latest_tag.outputs.minor }}
          PATCH=${{ steps.get_latest_tag.outputs.patch }}
          
          if [[ "${{ steps.determine_release.outputs.release_type }}" == "major" ]]; then
            NEW_TAG="v$((MAJOR + 1)).0.0"
          elif [[ "${{ steps.determine_release.outputs.release_type }}" == "minor" ]]; then
            NEW_TAG="v${MAJOR}.$((MINOR + 1)).0"
          else
            NEW_TAG="v${MAJOR}.${MINOR}.$((PATCH + 1))"
          fi
          
          echo "new_tag=${NEW_TAG}" >> $GITHUB_OUTPUT
          
          # Get PR author information and PR title
          PR_AUTHOR_NAME="${{ github.event.pull_request.user.name }}"
          PR_AUTHOR_EMAIL="${{ github.event.pull_request.user.email }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          
          # If PR author name is not available, use login
          if [ -z "$PR_AUTHOR_NAME" ]; then
            PR_AUTHOR_NAME="${{ github.event.pull_request.user.login }}"
          fi
          
          # If PR author email is not available, use GitHub's no-reply email with the login
          if [ -z "$PR_AUTHOR_EMAIL" ]; then
            PR_AUTHOR_EMAIL="${{ github.event.pull_request.user.login }}@users.noreply.github.com"
          fi
          
          git config --local user.email "$PR_AUTHOR_EMAIL"
          git config --local user.name "$PR_AUTHOR_NAME"
          git tag -a ${NEW_TAG} -m "Release ${NEW_TAG}: ${PR_TITLE}"
          git push origin ${NEW_TAG}

      - name: Create artifact
        run: |
          # Exclude files not needed in release
          mkdir -p release_content
          rsync -av --exclude='.git*' \
                    --exclude='CODE_OF_CONDUCT.md' \
                    --exclude='CONTRIBUTING.md' \
                    --exclude='.gitattributes' \
                    --exclude='.github' \
                    ./ release_content/

      - name: Create ZIP archive
        run: |
          cd release_content
          zip -r ../InfraBox-${{ steps.create_tag.outputs.new_tag }}.zip .
      
      - name: Create tarball
        run: |
          cd release_content
          tar -czf ../InfraBox-${{ steps.create_tag.outputs.new_tag }}.tar.gz .
          
      - name: Upload ZIP artifact
        uses: actions/upload-artifact@v4
        with:
          name: InfraBox-${{ steps.create_tag.outputs.new_tag }}.zip
          path: InfraBox-${{ steps.create_tag.outputs.new_tag }}.zip
          retention-days: 1

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v4
        with:
          name: InfraBox-${{ steps.create_tag.outputs.new_tag }}.tar.gz
          path: InfraBox-${{ steps.create_tag.outputs.new_tag }}.tar.gz
          retention-days: 1

      - name: Save release metadata
        run: |
          mkdir -p release_metadata
          echo "${{ steps.create_tag.outputs.new_tag }}" > release_metadata/tag.txt
          echo "${{ steps.determine_release.outputs.release_type }}" > release_metadata/type.txt
      
      - name: Upload release metadata
        uses: actions/upload-artifact@v4
        with:
          name: release-metadata
          path: release_metadata/
          retention-days: 1

  create-release:
    needs: tag-and-build
    runs-on: ubuntu-latest
    steps:
      - name: Download release metadata
        uses: actions/download-artifact@v4
        with:
          name: release-metadata
          path: release_metadata

      - name: Set environment variables
        run: |
          echo "NEW_TAG=$(cat release_metadata/tag.txt)" >> $GITHUB_ENV
          echo "RELEASE_TYPE=$(cat release_metadata/type.txt)" >> $GITHUB_ENV
      
      - name: Download ZIP artifact
        uses: actions/download-artifact@v4
        with:
          name: InfraBox-${{ needs.tag-and-build.outputs.new_tag }}.zip

      - name: Download tarball artifact
        uses: actions/download-artifact@v4
        with:
          name: InfraBox-${{ needs.tag-and-build.outputs.new_tag }}.tar.gz

      - name: Create GitHub Release
        id: create_release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = '${{ needs.tag-and-build.outputs.new_tag }}';
            const releaseTitle = `Release ${tag}`;
            const fs = require('fs');
            
            try {
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                name: releaseTitle,
                draft: true,
                generate_release_notes: true
              });
              // Write release info to file for next job
              fs.writeFileSync('release_id.txt', release.data.id.toString());
              fs.writeFileSync('release_notes.txt', release.data.body || '');
              
              // Upload ZIP file
              const zipFilePath = `InfraBox-${tag}.zip`;
              const zipFileContent = fs.readFileSync(zipFilePath);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: zipFilePath,
                data: zipFileContent
              });
              
              // Upload tarball
              const tarFilePath = `InfraBox-${tag}.tar.gz`;
              const tarFileContent = fs.readFileSync(tarFilePath);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: tarFilePath,
                data: tarFileContent
              });
              
              console.log(`Created draft release ${releaseTitle} with assets`);
              
              return {
                release_id: release.data.id,
                release_notes: release.data.body || 'No release notes available.'
              };
            } catch (error) {
              core.setFailed(`Release creation failed: ${error.message}`);
            }
          result-encoding: json
      
      - name: Upload release info
        uses: actions/upload-artifact@v4
        with:
          name: release-info
          path: |
            release_id.txt
            release_notes.txt
          retention-days: 1

  publish-discussion-post:
      needs: [tag-and-build, create-release]
      runs-on: ubuntu-latest
      steps:
        - name: Download release metadata
          uses: actions/download-artifact@v4
          with:
            name: release-metadata
            path: release_metadata

        - name: Download release info
          uses: actions/download-artifact@v4
          with:
            name: release-info
            path: release_info

        - name: Set environment variables
          run: |
            echo "NEW_TAG=$(cat release_metadata/tag.txt)" >> $GITHUB_ENV
            echo "RELEASE_TYPE=$(cat release_metadata/type.txt)" >> $GITHUB_ENV
            
        - name: Create New Discussion Post
          uses: actions/github-script@v6
          with:
            github-token: ${{ secrets.GITHUB_TOKEN }}
            script: |
              const fs = require('fs');
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              const tag = '${{ env.NEW_TAG }}';
              const releaseType = '${{ env.RELEASE_TYPE }}';
              const discussionTitle = `Fresh new InfraBox Release: ${tag}!`;
              const releaseNotes = fs.readFileSync('release_info/release_notes.txt', 'utf8');

              // Prepare the discussion body
              const discussionBody = `
              # InfraBox ${tag} has been released! ðŸš€
              
              We're excited to announce the release of InfraBox ${tag}. This is a ${releaseType} release.
              
              ## What's New
              
              ${releaseNotes}
              
              ## Try It Now!
              
              You can download the new version from the [GitHub Release page](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/${tag}).
              
              ---
              
              Thank you for your continuous support and for using InfraBox!
              --this post has been automatically generated by the InfraBox release workflow--
              `;
              
              try {
                // List discussion categories via generic request (more robust)
                const categoriesResp = await github.request('GET /repos/{owner}/{repo}/discussion-categories', {
                  owner,
                  repo
                });
                
                const categories = categoriesResp.data || [];
                
                if (!Array.isArray(categories) || categories.length === 0) {
                  core.warning('No discussion categories found or Discussions might be disabled. Skipping post creation.');
                  return;
                }
                
                // Select Announcements category
                let category = categories.find(c => c.name.replace(/[^\w\s]/gi, '').trim().toLowerCase().includes('announcements'));
                  if (!category) {
                    // fallback to first category
                    category = categories[0];
                    core.warning(`Could not find any category containing 'Announcements', using '${category.name}' instead.`);
                  }
                    
                // Create the discussion via generic request
                const createResp = await github.request('POST /repos/{owner}/{repo}/discussions', {
                  owner,
                  repo,
                  title: discussionTitle,
                  body: discussionBody,
                  category_id: category.id
                });
                
                console.log(`Discussion post created: ${createResp.data.html_url}`);
              } catch (error) {
                core.setFailed(`Failed to create discussion post: ${error.message}`);
              }